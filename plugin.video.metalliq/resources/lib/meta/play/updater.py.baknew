import os
import re
import zipfile
import contextlib
import urllib
import urllib2
import base64
import shutil
import time
import io
from urlparse import urlparse, urlunparse
from xbmcswift2 import xbmc, xbmcaddon, xbmcgui

from meta import plugin
from meta.gui import dialogs
from meta.play.players import EXTENSION

from language import get_string as _

data_dir   = "special://profile/addon_data/{0}".format(plugin.id)
data_dir   = xbmc.translatePath(data_dir)
extract_to = os.path.join(data_dir, "players")
url        = "https://api.github.com/repos/OpenELEQ/verified-metalliq-players/zipball"
ziptemp    = "special://profile/addons/packages/ziptemp"
dp         =  xbmcgui.DialogProgress()

# Check the last modified date of online file against our locally stored text file date
def Check_File_Date(url, datefile, localdate, dst):
    try:
        req = urllib2.Request(url)
        req.add_header('User-Agent','Mozilla/5.0 (Windows; U; Windows NT 5.1; en-GB; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3')
        conn = urllib2.urlopen(req)
        last_modified = conn.info().getdate('last-modified')
        last_modified = time.strftime('%Y%m%d%H%M%S', last_modified)
        if int(last_modified) > int(localdate):
            urllib.urlretrieve(url,dst)
            update_players_remote(url)
            writefile = open(datefile, 'w+')
            writefile.write(last_modified)
            writefile.close()
        try:
            if os.path.exists(dst):
                os.remove(dst)
        except:
            pass
    except:
        print"Failed with update: "+str(url)

# Grab the date stored locally and parse through to the main online check function
def Check_Updates(url, datefile, dst):
    if os.path.exists(datefile):
        readfile = open(datefile,'r')
        localdate = readfile.read()
        readfile.close()
    else:
        localdate = 0
    Check_File_Date(url, datefile, int(localdate), dst)

# Extract a zip with progress
def extract(_in, _out):
    dp.create('Extracting Zip File','','','')
    zin    = zipfile.ZipFile(_in,  'r')
    nFiles = float(len(zin.infolist()))
    count  = 0
    for item in zin.infolist():
        try:
            count += 1
            update = count / nFiles * 100
            dp.update(int(update))
            zin.extract(item, _out)
        except Exception, e:
            xbmc.log(str(e))
###################################################################
# OTHER USEFUL FUNCTIONS YOU MAY WANT TO USE WITH THIS IN YOUR CODE
###################################################################
# Download a zip with progress bar
def download(url, dest):
    dp = xbmcgui.DialogProgress()
    dp.create("Status...","Downloading Content",' ', ' ')
    dp.update(0)
    start_time=time.time()
    urllib.urlretrieve(url, dest, lambda nb, bs, fs: _pbhook(nb, bs, fs, dp, start_time))

# Dialog showing percentage of download complete and ETA
def _pbhook(numblocks, blocksize, filesize, dp, start_time):
    try:
        percent = min(numblocks * blocksize * 100 / filesize, 100)
        currently_downloaded = float(numblocks) * blocksize / (1024 * 1024)
        kbps_speed = numblocks * blocksize / (time.time() - start_time)
        if kbps_speed > 0:
            eta = (filesize - numblocks * blocksize) / kbps_speed
        else:
            eta = 0
        kbps_speed = kbps_speed / 1024
        total = float(filesize) / (1024 * 1024)
        mbs = '%.02f MB of %.02f MB' % (currently_downloaded, total)
        e = 'Speed: %.02f Kb/s ' % kbps_speed
        e += 'ETA: %02d:%02d' % divmod(eta, 60)
        dp.update(percent, mbs, e)
    except:
        percent = 100 
        dp.update(percent)
    if dp.iscanceled(): 
        dp.close()

# Basic function for reading the URL
def Open_URL(url):
    req = urllib2.Request(url)
    req.add_header('User-Agent' , 'Mozilla/5.0 (Windows; U; Windows NT 10.0; WOW64; Windows NT 5.1; en-GB; rv:1.9.0.3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36 Gecko/2008092417 Firefox/3.0.3')
    response = urllib2.urlopen(req)
    link     = response.read()
    response.close()
    return link.replace('\r','').replace('\n','').replace('\t','')

# Create a timestamp that matches the format of what we're grabbing from online, we'll store this each time we download a new one
def Timestamp():
    now = time.time()
    localtime = time.localtime(now)
    return time.strftime('%Y%m%d%H%M%S', localtime)

def remove_auth(url):
    parsed = urlparse(url)
    parts = list(parsed)
    parts[1] = parsed.hostname
    return urlunparse(parts)

def update_players(path):
    if path.startswith("http://") or path.startswith("https://"):
        return update_players_remote(path)
    return update_players_local(path)

def update_players_local(zip_path):
    extract_to = os.path.join(data_dir, "players")
    with contextlib.closing(zipfile.ZipFile(zip_path, "r")) as z:
        members = [x for x in z.namelist() if x.endswith(EXTENSION)]
        flat_extract(z, extract_to, members)
    return True

def update_players_remote(url):
    # Get username and password
    parsed = urlparse(url)
    username = parsed.username
    password = parsed.password
    if username is not None:
        if not password:
            password = plugin.keyboard(heading=_('Enter password'), hidden=True)
        if not password:
            return False
        url = remove_auth(url)
    # Try without authentication
    response = None
    try:
        response = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        if not username:
            return False
        url = e.geturl()
    # Retry with authentication
    if response is None:
        userandpass = base64.b64encode('%s:%s' % (username, password))
        auth = 'Basic %s' % userandpass.decode('ascii')
        request = urllib2.Request(url)
        request.add_header('Authorization', auth)
        try:
            response = urllib2.urlopen(request)
        except:
            return False
    extract_to = os.path.join(data_dir, "players")
    buffer = io.BytesIO(response.read())
    with contextlib.closing(zipfile.ZipFile(buffer)) as z:
        members = [x for x in z.namelist() if x.endswith(EXTENSION)]
        flat_extract(z, extract_to, members)
    return True

def empty_folder(folder):
    for filename in os.listdir(folder):
        file_path = os.path.join(folder, filename)
        try:
            if os.path.isfile(file_path):
                os.unlink(file_path)
        except Exception, e:
            traceback.print_exc()

def flat_extract(z, extract_to, members=None):
    if members is None:
        members = z.namelist()
    if not os.path.exists(extract_to):
        os.makedirs(extract_to)
    else:
        if dialogs.yesno(_("Update players"), _("Do you want to remove your existing players first?")):
            empty_folder(extract_to)
    for member in members:
        with contextlib.closing(z.open(member)) as source:
            target_path = os.path.join(extract_to, os.path.basename(member))
            with open(target_path, "wb") as target:
                shutil.copyfileobj(source, target)
